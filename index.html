<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"/>
  <title>Pattern Predictor Game - Advanced AI v5.1 (Entropy & UI Fix)</title>
  <style>
    body {
      display: flex;
      height: 100vh;
      margin: 0;
      background-color: #f0f2f5;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      overflow-x: hidden;
    }

    .sidebar {
      position: fixed;
      left: 0;
      top: 0;
      width: 120px; 
      height: 100%;
      background-color: #e9ecef;
      padding: 20px 10px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      align-items: center;
      z-index: 10;
      box-shadow: 2px 0 5px rgba(0,0,0,0.1);
    }
    .coin-display {
      font-size: 24px;
      font-weight: bold;
      color: #2a2a2a;
      margin-bottom: 20px; 
      background-color: #ffc107;
      padding: 8px 15px;
      border-radius: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .coin-display span {
      margin-left: 5px;
      font-size: 20px;
    }

    .sidebar-control-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      margin-bottom: 15px; 
    }
    .sidebar-control-group label {
      font-size: 13px; 
      margin-bottom: 6px;
      color: #333;
      font-weight: 500;
    }
    .value-input-wrapper { 
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .value-input-wrapper button {
      width: 28px;
      height: 28px;
      font-size: 18px;
      font-weight: bold;
      border: 1px solid #ccc;
      background-color: #f8f9fa;
      cursor: pointer;
      color: #333;
      line-height: 1;
    }
    .value-input-wrapper button:hover {
      background-color: #e2e6ea;
    }
    .value-input-wrapper button:first-child {
      border-radius: 5px 0 0 5px;
    }
    .value-input-wrapper button:last-child {
      border-radius: 0 5px 5px 0;
    }
    .value-input-wrapper input {
      height: 28px;
      padding: 5px;
      font-size: 14px; 
      border: 1px solid #ccc;
      border-left: none;
      border-right: none;
      border-radius: 0;
      text-align: center;
      box-sizing: border-box;
      -moz-appearance: textfield;
    }
    #stake, #iterations { width: 40px; }
    #samples { width: 55px; } 

    .value-input-wrapper input::-webkit-outer-spin-button,
    .value-input-wrapper input::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }

    .main {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      margin-left: 120px; 
      padding: 15px;
      box-sizing: border-box;
      position: relative;
    }
    
    .game-content-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 450px;
    }

    #btnToggleConfidence {
      position: absolute;
      top: 15px;
      right: 15px;
      background-color: #28a745;
      color: white;
      border: none;
      padding: 7px 12px;
      font-size: 13px;
      border-radius: 5px;
      cursor: pointer;
      z-index: 5;
      box-shadow: 0 1px 3px rgba(0,0,0,0.15);
    }
    #btnToggleConfidence:hover {
      background-color: #218838;
    }
    #btnAIGuess {
      position: absolute;
      top: 55px;
      right: 15px;
      background-color: #17a2b8;
      color: white;
      border: none;
      padding: 7px 12px;
      font-size: 13px;
      border-radius: 5px;
      cursor: pointer;
      z-index: 5;
      box-shadow: 0 1px 3px rgba(0,0,0,0.15);
    }
    #btnAIGuess:hover {
      background-color: #138496;
    }
    #btnAIGuess:disabled {
      background-color: #adb5bd !important;
      cursor: not-allowed;
    }

    .game-info-area {
      text-align: center;
      margin-bottom: 20px;
      min-height: 65px;
      width: 100%;
    }
    #scoreDisplay, #trialsDisplay {
      font-size: 18px;
      font-weight: 600;
      color: #343a40;
      display: block;
      margin-bottom: 4px;
    }
    #statusMessage {
      font-size: 15px;
      color: #495057;
      margin-top: 8px;
      min-height: 1.3em;
      font-style: italic;
    }

    .button-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
      width: 100%;
      max-width: 340px;
      margin-bottom: 25px;
    }
    .grid-button-container {
      position: relative;
    }
    .grid-button {
      width: 100%;
      aspect-ratio: 1 / 1;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      font-weight: bold;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      background-color: #ff7675;
      color: white;
      transition: background-color 0.2s, transform 0.1s;
      box-sizing: border-box;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .grid-button:active {
      transform: scale(0.95);
    }
    .grid-button.t {
      background-color: #55efc4;
      color: #2d3436;
    }
    .confidence-text {
      position: absolute;
      bottom: 3px;
      right: 5px;
      font-size: 10px;
      color: #2d3436;
      background-color: rgba(255, 255, 255, 0.8);
      padding: 1px 4px;
      border-radius: 3px;
      pointer-events: none;
    }

    .footer {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      width: 100%;
      max-width: 380px;
    }
    .action-button {
      padding: 12px 15px;
      font-size: 15px;
      font-weight: 500;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      width: 100%;
      box-sizing: border-box;
      transition: background-color 0.2s, transform 0.1s;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .action-button:active {
      transform: translateY(1px);
    }
    .action-button:disabled {
      background-color: #adb5bd !important;
      color: #f8f9fa !important;
      cursor: not-allowed;
      box-shadow: none;
    }

    #btnScore { background-color: #28a745; color: white; }
    #btnAnswer { background-color: #ffc107; color: #212529; }
    #btnDouble { background-color: #007bff; color: white; }
    #btnRestart { background-color: #dc3545; color: white; }
    #btnHowTo {
      background-color: #6c757d;
      color: white;
      grid-column: span 2;
    }

    .modal {
      display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background-color: rgba(0, 0, 0, 0.65); z-index: 1000;
    }
    .modal-content {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background-color: #fff; padding: 30px; border-radius: 12px;
      width: 90%; max-width: 500px; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      max-height: 85vh; overflow-y: auto;
    }
    .close-button {
      position: absolute; top: 15px; right: 20px; font-size: 30px;
      cursor: pointer; color: #6c757d; background: none; border: none;
    }
    .modal-content h3 { margin-top: 0; color: #343a40; font-size: 22px; margin-bottom: 15px;}
    .modal-content p { font-size: 16px; line-height: 1.6; color: #495057; }
    .modal-content ul { padding-left: 20px; margin-bottom: 0;}
    .modal-content li { margin: 10px 0; font-size: 15px; color: #495057;}

    @media (max-width: 768px) {
      .sidebar { width: 100px; padding: 15px 5px;} 
      .main { margin-left: 100px; } 
      .coin-display { padding: 6px 10px; font-size: 20px; margin-bottom: 15px; }
      .coin-display span { font-size: 18px; }
      .sidebar-control-group label { font-size: 12px; margin-bottom: 5px; }
      .value-input-wrapper button { width: 24px; height: 24px; font-size: 16px;}
      .value-input-wrapper input { height: 24px; font-size: 13px;}
      #stake, #iterations { width: 36px; }
      #samples { width: 45px; }
    }

    @media (max-width: 500px) {
      .main { padding: 10px; }
      #btnToggleConfidence, #btnAIGuess { font-size: 12px; padding: 6px 10px; top:10px; right:10px;}
      #btnAIGuess { top: 45px; }
      .game-info-area { margin-bottom: 15px; min-height: 60px; }
      #scoreDisplay, #trialsDisplay { font-size: 16px; }
      #statusMessage { font-size: 14px;}
      .button-grid { max-width: 300px; gap: 6px; }
      .grid-button { font-size: 18px; border-radius: 6px; }
      .confidence-text { font-size: 9px; }
      .footer { max-width: 300px; gap: 10px; }
      .action-button { font-size: 14px; padding: 10px 12px; border-radius: 5px;}
    }
  </style>
</head>
<body>
  <div class="sidebar">
    <div class="coin-display">ðŸª™<span id="coins">100</span></div>
    
    <div class="sidebar-control-group">
      <label for="stake">Challenge</label>
      <div class="value-input-wrapper">
        <button id="decrementStake" aria-label="Decrement stake">-</button>
        <input type="number" id="stake" value="10" min="1" step="1">
        <button id="incrementStake" aria-label="Increment stake">+</button>
      </div>
    </div>

    <div class="sidebar-control-group">
      <label for="iterations">AI Iterations</label>
      <div class="value-input-wrapper">
        <button id="decrementIterations" aria-label="Decrement iterations">-</button>
        <input type="number" id="iterations" value="10" min="10" step="1">
        <button id="incrementIterations" aria-label="Increment iterations">+</button>
      </div>
    </div>

    <div class="sidebar-control-group">
      <label for="samples">AI Samples</label>
      <div class="value-input-wrapper">
        <button id="decrementSamples" aria-label="Decrement samples">-</button>
        <input type="number" id="samples" value="3000" min="3000" step="100">
        <button id="incrementSamples" aria-label="Increment samples">+</button>
      </div>
    </div>
  </div>

  <div class="main">
    <button id="btnToggleConfidence">Confidence %</button>
    <button id="btnAIGuess">AI Next Guess</button>
    <div class="game-content-wrapper">
      <div class="game-info-area">
        <span id="scoreDisplay">Score: ? / 16</span>
        <span id="trialsDisplay">Trials: 0 / 9</span>
        <div id="statusMessage">New game started!</div>
      </div>

      <div id="gridDiv" class="button-grid"></div>

      <div class="footer">
        <button id="btnScore" class="action-button">Check Score</button>
        <button id="btnAnswer" class="action-button">Reveal Pattern</button>
        <button id="btnDouble" class="action-button" disabled>X2</button>
        <button id="btnRestart" class="action-button">Restart</button>
        <button id="btnHowTo" class="action-button">How to Play</button>
      </div>
    </div>
    <div id="statusMessageFooter" style="text-align:center; margin-top:10px; font-size:12px; color: #555;"></div>
  </div>

  <div id="modal" class="modal">
    <div class="modal-content">
      <button class="close-button" onclick="hideModal()" aria-label="Close modal">Ã—</button>
      <h3>How to Play</h3>
      <p>Match the hidden pattern of 'T's and 'F's in the 4x4 grid!</p>
      <ul>
        <li>Tap a button to switch its state between 'T' (True) and 'F' (False).</li>
        <li>"Check Score" shows how many of your guesses match the hidden pattern. You have a maximum of <span id="max-actions-info">9</span> tries per game. Your score and trials taken will appear at the top.</li>
        <li>Get a perfect score (16) to win your stake as profit.</li>
        <li>Lose your Challenge Coins if you fail to get a perfect score within the allowed tries.</li>
        <li>Use "X2" after a loss to double your next challenge amount.</li>
        <li><strong>Confidence %:</strong> Tap to see the AI's current belief about each square being 'T'. (Based on Monte Carlo sampling)</li>
        <li><strong>AI Next Guess:</strong> Tap this to have the AI set the grid to its current best guess, chosen to maximize information gain (Entropy method). Use this, then "Check Score".</li>
        <li>"Reveal Pattern" shows the answer but ends the game (you lose).</li>
        <li><strong>AI Iterations:</strong> Adjust AI refinement cycles for the Monte Carlo sampling stage (Min: <span id="min-iterations-info">10</span>). More iterations can improve the quality of samples the Entropy AI considers and also affect the perfomance of your device.</li>
        <li><strong>AI Samples:</strong> Set how many example patterns the AI's Monte Carlo stage considers (Min: <span id="min-samples-info">3000</span>). More samples can lead to better hypotheses for the Entropy AI. It can also lead to perfomance drop.</li>
      </ul>
    </div>
  </div>

  <script>
    const N = 16; 
    const MAX_ACTIONS = 10; 

    let actions = 0;
    let patT = Array(N).fill(0);
    let patG = Array(N).fill(0);
    let currentScore = 0;
    let coins = Math.floor(Math.random() * 101) + 50;

    const gridDiv = document.getElementById('gridDiv');
    const stakeInput = document.getElementById('stake');
    const coinsDisplay = document.getElementById('coins');
    const scoreDisplayElement = document.getElementById('scoreDisplay');
    const trialsDisplayElement = document.getElementById('trialsDisplay');
    const statusMessageElement = document.getElementById('statusMessage');
    const statusMessageFooterElement = document.getElementById('statusMessageFooter');
    const maxActionsInfoDisplay = document.getElementById('max-actions-info');
    const decrementStakeBtn = document.getElementById('decrementStake');
    const incrementStakeBtn = document.getElementById('incrementStake');
    const btnAIGuessDOM = document.getElementById('btnAIGuess');

    const iterationsInput = document.getElementById('iterations');
    const decrementIterationsBtn = document.getElementById('decrementIterations');
    const incrementIterationsBtn = document.getElementById('incrementIterations');
    const samplesInput = document.getElementById('samples');
    const decrementSamplesBtn = document.getElementById('decrementSamples');
    const incrementSamplesBtn = document.getElementById('incrementSamples');
    
    const minIterationsInfoSpan = document.getElementById('min-iterations-info');
    const minSamplesInfoSpan = document.getElementById('min-samples-info');

    const btns = [];
    const confidenceSpans = [];

    let ai_xs = []; 
    let ai_ys = []; 
    let ai_samples = []; 
    let ai_weights = []; 
    let ai_currentBelief = new Array(N).fill(0);
    let ai_totalOnesInTruePattern = -1;
    let ai_totalZerosInTruePattern = -1;
    let ai_pastBeliefs = []; 
    let ai_isStuckCounter = 0; 
    const AI_STUCK_THRESHOLD = 2; 
    
    const MIN_ITERATIONS = 10;
    const MIN_SAMPLES = 3000;
    let currentNumSamples = MIN_SAMPLES; 
    let currentAiMaxIterations = MIN_ITERATIONS;
    
    let predictorConfidences = new Array(N).fill(0.5); 
    const LOG2 = Math.log2(1); 

    const MAX_ENTROPY_CANDIDATES_BASE = 20; 
    const MAX_ENTROPY_CANDIDATES_PER_FLIP_TYPE = N; 
    const MAX_ENTROPY_RANDOM_CANDIDATES = 10; 

    let showConfidence = false;

    function initGrid() {
      statusMessageFooterElement.innerHTML = "By E5";
      for (let i = 0; i < N; i++) {
        const container = document.createElement('div');
        container.className = 'grid-button-container';
        const btn = document.createElement('button');
        btn.className = 'grid-button';
        btn.innerHTML = 'F';
        btn.onclick = () => toggleButton(i);
        const confSpan = document.createElement('span');
        confSpan.className = 'confidence-text';
        confSpan.style.display = 'none';
        btns.push(btn);
        confidenceSpans.push(confSpan);
        container.appendChild(btn);
        container.appendChild(confSpan);
        gridDiv.appendChild(container);
      }
    }

    function toggleButton(i) {
      if (actions < MAX_ACTIONS && !btns[i].disabled) {
        patG[i] = 1 - patG[i];
        updateGridButtonVisual(i);
      }
    }

    function updateGridButtonVisual(i) {
      btns[i].innerHTML = patG[i] ? 'T' : 'F';
      btns[i].className = 'grid-button' + (patG[i] ? ' t' : '');
    }

    function updateAllGridVisualsFromPatG() {
      for (let i = 0; i < N; i++) {
        updateGridButtonVisual(i);
      }
    }

    function generatePattern() {
      let sumT;
      const initialGuessForComparison = new Array(N).fill(0);
      do {
        sumT = 0;
        for (let i = 0; i < N; i++) {
          patT[i] = Math.random() > 0.5 ? 1 : 0;
          if (patT[i] === 1) sumT++;
        }
      } while (sumT === 0 || sumT === N || patT.every((val, idx) => val === initialGuessForComparison[idx]));
    }

    function checkScore(pattern, guess) {
      if (!pattern || !guess || pattern.length !== N || guess.length !== N) {
        console.error("Invalid pattern or guess for checkScore", pattern, guess);
        return 0;
      }
      let score = 0;
      for (let i = 0; i < N; i++) {
        if (pattern[i] === guess[i]) score++;
      }
      return score;
    }

    function initializeSamples() {
      ai_samples = [];
      ai_weights = []; 
      for (let s = 0; s < currentNumSamples; s++) {
        const sample = new Array(N);
        let onesCount = ai_totalOnesInTruePattern;
        if (onesCount === -1) { 
          for (let i = 0; i < N; i++) sample[i] = Math.random() > 0.5 ? 1 : 0;
        } else { 
          sample.fill(0);
          const indices = [...Array(N).keys()];
          for (let i = indices.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [indices[i], indices[j]] = [indices[j], indices[i]];
          }
          for (let i = 0; i < onesCount; i++) sample[indices[i]] = 1;
        }
        ai_samples.push(sample);
        ai_weights.push(1 / currentNumSamples);
      }
    }

    function refineAISamples() { 
      if (ai_xs.length === 0 || ai_samples.length === 0) return;

      for (let iter = 0; iter < currentAiMaxIterations; iter++) {
        let totalWeight = 0;
        for (let s = 0; s < ai_samples.length; s++) { 
          let logLikelihood = 0;
          for (let k = 0; k < ai_xs.length; k++) {
            const guess = ai_xs[k];
            const observedScore = ai_ys[k];
            const predictedScore = checkScore(ai_samples[s], guess);
            const error = Math.abs(observedScore - predictedScore);
            logLikelihood += -error * error; 
          }
          ai_weights[s] = Math.exp(logLikelihood);
          totalWeight += ai_weights[s];
        }

        if (totalWeight > 0 && isFinite(totalWeight)) {
          for (let s = 0; s < ai_samples.length; s++) ai_weights[s] /= totalWeight;
        } else { 
          ai_weights.fill(1 / ai_samples.length);
        }
        
        const newSamples = [];
        const cumulativeWeights = [];
        let sum = 0;
        for (let s = 0; s < ai_samples.length; s++) {
          sum += ai_weights[s];
          cumulativeWeights.push(sum);
        }
        if (ai_samples.length > 0 && cumulativeWeights.length > 0) {
             cumulativeWeights[cumulativeWeights.length - 1] = 1.0;
        }

        for (let s = 0; s < currentNumSamples; s++) { 
          const r = Math.random();
          let idx = 0;
          while (idx < ai_samples.length - 1 && r > cumulativeWeights[idx]) {
            idx++;
          }
          const baseSample = [...ai_samples[idx]]; 
          if (Math.random() < 0.15 || iter < 2) { 
             const i = Math.floor(Math.random() * N);
            if (ai_totalOnesInTruePattern !== -1) { 
                const j = Math.floor(Math.random() * N);
                if (baseSample[i] !== baseSample[j]) {
                    [baseSample[i], baseSample[j]] = [baseSample[j], baseSample[i]];
                } else { 
                    baseSample[i] = 1 - baseSample[i];
                }
            } else { 
                baseSample[i] = 1 - baseSample[i];
            }
          }
          if (ai_totalOnesInTruePattern !== -1) {
            let currentOnes = baseSample.reduce((c, bit) => c + bit, 0);
            let attempts = 0;
            while(currentOnes !== ai_totalOnesInTruePattern && attempts < N*2) {
                const k = Math.floor(Math.random() * N);
                if(currentOnes > ai_totalOnesInTruePattern && baseSample[k] === 1) {
                    baseSample[k] = 0; currentOnes--;
                } else if (currentOnes < ai_totalOnesInTruePattern && baseSample[k] === 0) {
                    baseSample[k] = 1; currentOnes++;
                }
                attempts++;
            }
          }
          newSamples.push(baseSample);
        }
        ai_samples = newSamples;
        ai_weights.fill(1 / currentNumSamples); 
      }

      for (let i = 0; i < N; i++) {
        let prob = 0;
        for (let s = 0; s < ai_samples.length; s++) {
          prob += ai_samples[s][i];
        }
        predictorConfidences[i] = ai_samples.length > 0 ? prob / ai_samples.length : 0.5;
      }
    }
    
    function generateEntropyBasedGuess() {
        const stringifiedSamples = new Set();
        const uniqueConsistentSamples = [];
        for (const sample of ai_samples) {
            let consistent = true;
            for (let k = 0; k < ai_xs.length; k++) {
                if (checkScore(sample, ai_xs[k]) !== ai_ys[k]) {
                    consistent = false;
                    break;
                }
            }
            if (consistent) {
                const sStr = sample.join('');
                if (!stringifiedSamples.has(sStr)) {
                    uniqueConsistentSamples.push(sample);
                    stringifiedSamples.add(sStr);
                }
            }
        }

        if (uniqueConsistentSamples.length === 0) {
            console.warn("Entropy: No consistent samples found. Generating random fallback.");
            const fallbackGuess = new Array(N);
            if (ai_totalOnesInTruePattern !== -1) {
                fallbackGuess.fill(0);
                // Simplified placement for known count if N is small, then shuffle
                let tempIndices = Array.from({length: N}, (_, i) => i);
                for(let i=0; i<ai_totalOnesInTruePattern; ++i) fallbackGuess[tempIndices[i]] = 1;
                for (let i = N - 1; i > 0; i--) { // Shuffle the whole array
                    const j = Math.floor(Math.random() * (i + 1));
                    [fallbackGuess[i], fallbackGuess[j]] = [fallbackGuess[j], fallbackGuess[i]];
                }
            } else {
                for (let i = 0; i < N; i++) fallbackGuess[i] = Math.random() > 0.5 ? 1 : 0;
            }
            return fallbackGuess;
        }

        if (uniqueConsistentSamples.length === 1) {
            return [...uniqueConsistentSamples[0]]; 
        }

        const candidateGuessesSet = new Set(); 
        
        if (ai_totalOnesInTruePattern === -1) {
            candidateGuessesSet.add(new Array(N).fill(0).join(''));
            candidateGuessesSet.add(new Array(N).fill(1).join(''));
        }

        let baseForFlips = predictorConfidences.map(p => p > 0.5 ? 1 : 0); // Use current MC belief as base
        candidateGuessesSet.add(baseForFlips.join(''));


        for (let i = 0; i < N && candidateGuessesSet.size < MAX_ENTROPY_CANDIDATES_BASE + MAX_ENTROPY_CANDIDATES_PER_FLIP_TYPE; i++) {
            const candidate = [...baseForFlips];
            candidate[i] = 1 - candidate[i];
            candidateGuessesSet.add(candidate.join(''));
        }
        
        // Add some unique consistent samples themselves as candidates
        for(let i=0; i < MAX_ENTROPY_RANDOM_CANDIDATES && i < uniqueConsistentSamples.length; ++i) {
            candidateGuessesSet.add(uniqueConsistentSamples[i].join(''));
        }

        let bestGuessPattern = null;
        let minExpectedEntropy = Infinity;

        candidateGuessesSet.forEach(guessStr => {
            const guessArray = guessStr.split('').map(Number);
            let expectedEntropyForThisGuess = 0;
            const scoreDistribution = new Array(N + 1).fill(0); 

            for (const sample of uniqueConsistentSamples) {
                const score = checkScore(sample, guessArray);
                scoreDistribution[score]++;
            }

            for (let s_obs = 0; s_obs <= N; s_obs++) {
                if (scoreDistribution[s_obs] > 0) {
                    const prob_s_obs = scoreDistribution[s_obs] / uniqueConsistentSamples.length;
                    // Entropy H = - Sum p_i log2(p_i). Here, for a partition, entropy is log2(|partition_size|)
                    // We want to minimize the expected size of the partition after guessing.
                    // The term for expected entropy for a guess is Sum_{s_obs} P(s_obs|guess) * H(Patterns | guess, s_obs)
                    // H(Patterns | guess, s_obs) is log2(number of patterns consistent with guess and s_obs)
                    // which is log2(scoreDistribution[s_obs])
                    const entropy_s_obs = Math.log2(scoreDistribution[s_obs]); 
                    expectedEntropyForThisGuess += prob_s_obs * entropy_s_obs;
                }
            }
            
            if (expectedEntropyForThisGuess < minExpectedEntropy) {
                minExpectedEntropy = expectedEntropyForThisGuess;
                bestGuessPattern = guessArray;
            }
        });
        
        if (!bestGuessPattern && uniqueConsistentSamples.length > 0) {
            console.warn("Entropy: No best guess found from candidates, returning first unique consistent sample.");
            return [...uniqueConsistentSamples[0]]; 
        } else if (!bestGuessPattern) { // Should be covered by earlier check but as a safeguard
             return baseForFlips; // Fallback to MC belief
        }
        
        return bestGuessPattern;
    }


    function determineAINextActionAndUpdateBeliefs(playerSubmittedGuess, playerScoreFromPlayerGuess) {
      let reinitializeSamplesNeeded = false;
      if (playerSubmittedGuess && playerScoreFromPlayerGuess !== null) {
        const existingGuessIndex = ai_xs.findIndex(existingX => existingX.every((val, idx) => val === playerSubmittedGuess[idx]));
        if (existingGuessIndex === -1) {
          ai_xs.push([...playerSubmittedGuess]);
          ai_ys.push(playerScoreFromPlayerGuess);
        }

        let previousTotalOnes = ai_totalOnesInTruePattern;
        if (playerSubmittedGuess.every(bit => bit === 0)) {
          ai_totalZerosInTruePattern = playerScoreFromPlayerGuess;
          ai_totalOnesInTruePattern = N - playerScoreFromPlayerGuess;
        } else if (playerSubmittedGuess.every(bit => bit === 1)) {
          ai_totalOnesInTruePattern = playerScoreFromPlayerGuess;
          ai_totalZerosInTruePattern = N - playerScoreFromPlayerGuess;
        }
        if (ai_totalOnesInTruePattern !== -1 && previousTotalOnes !== ai_totalOnesInTruePattern) {
            reinitializeSamplesNeeded = true; 
        }
      }

      if (ai_samples.length === 0 || reinitializeSamplesNeeded || ai_samples.length !== currentNumSamples) {
        initializeSamples(); 
      }

      refineAISamples(); 
      
      let newProposedAIBelief;
      if (ai_xs.length === 0 && ai_totalOnesInTruePattern === -1) {
        newProposedAIBelief = new Array(N).fill(0);
      } else {
        newProposedAIBelief = generateEntropyBasedGuess(); 
      }
      
      const isEqualToPrevious = ai_pastBeliefs.length > 0 && newProposedAIBelief.every((val, idx) => val === ai_pastBeliefs[ai_pastBeliefs.length - 1][idx]);
      if (isEqualToPrevious && (!playerScoreFromPlayerGuess || playerScoreFromPlayerGuess < N)) {
        ai_isStuckCounter++;
      } else {
        ai_isStuckCounter = 0;
      }
       
      // Get current number of unique consistent samples to avoid unnecessary mutation if solved
      let currentUniqueConsistentSamplesCount = 0;
      if (ai_samples.length > 0) {
          const tempSet = new Set();
          ai_samples.forEach(s => {
              let consistent = true;
              for(let k=0; k<ai_xs.length; ++k) if(checkScore(s, ai_xs[k]) !== ai_ys[k]) {consistent=false; break;}
              if(consistent) tempSet.add(s.join(''));
          });
          currentUniqueConsistentSamplesCount = tempSet.size;
      }


      if (ai_isStuckCounter >= AI_STUCK_THRESHOLD && currentUniqueConsistentSamplesCount > 1) { 
        statusMessageElement.textContent += " (AI trying to break stuck pattern)";
        let mutatedBelief = [...newProposedAIBelief];
        const i = Math.floor(Math.random() * N);
        mutatedBelief[i] = 1 - mutatedBelief[i]; 
        if (ai_totalOnesInTruePattern !== -1) { 
            let currentOnes = mutatedBelief.reduce((sum, bit) => sum + bit, 0);
            let attempts = 0;
            while (currentOnes !== ai_totalOnesInTruePattern && attempts < N * 2) {
                const k = Math.floor(Math.random() * N);
                if (currentOnes > ai_totalOnesInTruePattern && mutatedBelief[k] === 1) {
                    mutatedBelief[k] = 0; currentOnes--;
                } else if (currentOnes < ai_totalOnesInTruePattern && mutatedBelief[k] === 0) {
                    mutatedBelief[k] = 1; currentOnes++;
                }
                attempts++;
            }
        }
        newProposedAIBelief = mutatedBelief;
        ai_isStuckCounter = 0; 
      }

      ai_currentBelief = [...newProposedAIBelief];
      if (ai_pastBeliefs.length > 5) ai_pastBeliefs.shift();
      ai_pastBeliefs.push([...ai_currentBelief]);
      if (showConfidence) displayConfidences(); 
    }

    function displayConfidences() {
      confidenceSpans.forEach((span, i) => {
        span.innerHTML = `${(predictorConfidences[i] * 100).toFixed(0)}%`;
        span.style.display = showConfidence ? 'block' : 'none';
      });
    }

    function toggleConfidenceDisplay() {
      showConfidence = !showConfidence;
      displayConfidences();
    }
    document.getElementById('btnToggleConfidence').onclick = toggleConfidenceDisplay;

    function handleAIGuessButtonClick() {
      if (actions >= MAX_ACTIONS || btns[0].disabled) return;
      if(ai_xs.length === 0 && ai_pastBeliefs.length === 0 && ai_totalOnesInTruePattern === -1) { 
           determineAINextActionAndUpdateBeliefs(null,null); // This will set ai_currentBelief to all 0s
      } else if (ai_pastBeliefs.length === 0) { // If not true first, but no beliefs yet, form one
            determineAINextActionAndUpdateBeliefs(null,null);
      }


      patG = [...ai_currentBelief];
      updateAllGridVisualsFromPatG();
      statusMessageElement.textContent = "AI set the grid. Now Check Score.";
      if (showConfidence) displayConfidences();
    }
    btnAIGuessDOM.onclick = handleAIGuessButtonClick;

    function handleScoreCheck() {
      if (actions < MAX_ACTIONS) {
        currentScore = checkScore(patT, patG);
        actions++;

        scoreDisplayElement.textContent = `Score: ${currentScore} / ${N}`;
        trialsDisplayElement.textContent = `Trials: ${actions} / ${MAX_ACTIONS}`;
        statusMessageElement.textContent = `Checked score: ${currentScore}/${N}.`;

        determineAINextActionAndUpdateBeliefs([...patG], currentScore);

        if (currentScore === N) endGame(true);
        else if (actions >= MAX_ACTIONS) endGame(false);

        btnAIGuessDOM.disabled = (actions >= MAX_ACTIONS || currentScore === N);
      }
    }

    function revealAnswer() {
      patG = [...patT];
      updateAllGridVisualsFromPatG();
      currentScore = N;
      endGame(false, true);
    }

    function doubleStake() {
      let currentStake = parseInt(stakeInput.value) || 1;
      let maxPossibleStake = coins > 0 ? coins : 1;
      let newStake = Math.min(currentStake * 2, maxPossibleStake);
      stakeInput.value = newStake;
      updateStakeButtonStates();
      document.getElementById('btnDouble').disabled = true;
      statusMessageElement.textContent = `Next stake doubled to ${newStake}.`;
    }

    function endGame(isWin, revealed = false) {
      scoreDisplayElement.textContent = `Final Score: ${currentScore} / ${N}`;
      trialsDisplayElement.textContent = `Trials: ${actions} / ${MAX_ACTIONS}`;
      let stake = parseInt(stakeInput.value) || 1;
      let message = "";
      if (isWin) {
        coins += stake;
        message = `Perfect! You won ${stake} coins!`;
      } else {
        coins -= stake;
        message = revealed ? `Pattern revealed. Lost ${stake} coins.` : `Game Over! Lost ${stake} coins.`;
      }
      coins = Math.max(0, coins);
      coinsDisplay.textContent = coins;
      statusMessageElement.textContent = message;
      btns.forEach(btn => btn.disabled = true);
      document.getElementById('btnScore').disabled = true;
      document.getElementById('btnAnswer').disabled = true;
      btnAIGuessDOM.disabled = true;

      if (coins > 0) {
        document.getElementById('btnDouble').disabled = isWin;
        stakeInput.disabled = false;
        if (parseInt(stakeInput.value) > coins) stakeInput.value = coins;
        if ( (isNaN(parseInt(stakeInput.value)) || parseInt(stakeInput.value) < 1) && coins > 0) stakeInput.value = 1;
      } else {
        document.getElementById('btnDouble').disabled = true;
        stakeInput.value = 0;
        stakeInput.disabled = true;
        statusMessageElement.textContent += " You're out of coins!";
      }
      updateStakeButtonStates();
    }

    function restart() {
      actions = 0;
      currentScore = 0;
      scoreDisplayElement.textContent = `Score: ? / ${N}`;
      trialsDisplayElement.textContent = `Trials: 0 / ${MAX_ACTIONS}`;
      patG.fill(0);
      updateAllGridVisualsFromPatG();
      generatePattern();

      ai_xs = [];
      ai_ys = [];
      ai_samples = [];
      ai_weights = [];
      ai_totalOnesInTruePattern = -1;
      ai_totalZerosInTruePattern = -1;
      ai_pastBeliefs = [];
      ai_isStuckCounter = 0;
      predictorConfidences.fill(0.5);
      
      initializeSamples(); 
      determineAINextActionAndUpdateBeliefs(null, null); 

      btns.forEach(btn => btn.disabled = false);
      document.getElementById('btnScore').disabled = false;
      document.getElementById('btnAnswer').disabled = false;
      document.getElementById('btnDouble').disabled = true;
      btnAIGuessDOM.disabled = false;

      if (coins === 0) {
        stakeInput.value = 0;
        stakeInput.disabled = true;
        document.getElementById('btnScore').disabled = true;
        btnAIGuessDOM.disabled = true;
        statusMessageElement.textContent = "Restarted. You have no coins to play.";
      } else {
        stakeInput.disabled = false;
        let currentStakeVal = parseInt(stakeInput.value);
        if (isNaN(currentStakeVal) || currentStakeVal <= 0 || currentStakeVal > coins) {
          stakeInput.value = Math.max(1, Math.min(coins, 10));
        }
        statusMessageElement.textContent = "New game started!";
      }
      updateStakeButtonStates();
      updateIterationsButtonsState();
      updateSamplesButtonsState();
    }

    function showModal() { document.getElementById('modal').style.display = 'block'; }
    function hideModal() { document.getElementById('modal').style.display = 'none'; }

    function updateStakeValue(change) {
      let currentValue = parseInt(stakeInput.value) || 0;
      let newValue = currentValue + change;
      if (coins === 0) stakeInput.value = 0;
      else stakeInput.value = Math.max(1, Math.min(newValue, coins));
      updateStakeButtonStates();
    }
    function updateStakeButtonStates() {
      const val = parseInt(stakeInput.value);
      const stakeDisabled = stakeInput.disabled; // Check if input itself is disabled (e.g. 0 coins)
      decrementStakeBtn.disabled = stakeDisabled || isNaN(val) || val <= 1;
      incrementStakeBtn.disabled = stakeDisabled || isNaN(val) || val >= coins;
    }
    stakeInput.addEventListener('input', function() { // Live update for button states
        updateStakeButtonStates();
    });
    stakeInput.addEventListener('blur', function() { // Final validation and update
      let value = parseInt(this.value);
      if (isNaN(value) || value < 1 && coins > 0) {
        this.value = 1;
      } else if (value > coins && coins > 0) {
        this.value = coins;
      } else if (coins === 0) {
        this.value = 0;
      }
      // If it's still NaN after trying to fix (e.g., empty string and coins > 0), set to 1.
      if (isNaN(parseInt(this.value)) && coins > 0) this.value = 1;

      updateStakeButtonStates();
    });
    decrementStakeBtn.onclick = () => updateStakeValue(-1);
    incrementStakeBtn.onclick = () => updateStakeValue(1);

    // --- Iterations Controls (Fixed UI interaction) ---
    iterationsInput.addEventListener('input', function() {
        updateIterationsButtonsState(); // Update buttons based on current text
    });
    iterationsInput.addEventListener('blur', function() {
        let value = parseInt(this.value);
        if (isNaN(value) || value < MIN_ITERATIONS) {
            this.value = MIN_ITERATIONS;
        }
        currentAiMaxIterations = parseInt(this.value);
        updateIterationsButtonsState();
    });
    function updateIterationsButtonsState() {
        const val = parseInt(iterationsInput.value);
        decrementIterationsBtn.disabled = isNaN(val) || val <= MIN_ITERATIONS;
        // No specific upper bound for increment button, user can type.
    }
    decrementIterationsBtn.onclick = () => updateIterationsValue(-1);
    incrementIterationsBtn.onclick = () => updateIterationsValue(1);
    function updateIterationsValue(change) { // For +/- buttons
      let currentValue = parseInt(iterationsInput.value);
      if(isNaN(currentValue)) currentValue = MIN_ITERATIONS; // If input was bad, start from min
      let newValue = currentValue + change;
      iterationsInput.value = Math.max(MIN_ITERATIONS, newValue);
      currentAiMaxIterations = parseInt(iterationsInput.value);
      updateIterationsButtonsState();
    }


    // --- Samples Controls (Fixed UI interaction) ---
    samplesInput.addEventListener('input', function() {
        updateSamplesButtonsState(); // Update buttons based on current text
    });
    samplesInput.addEventListener('blur', function() {
        let oldValueForReinit = currentNumSamples; // Capture before potential change
        let value = parseInt(this.value);
        if (isNaN(value) || value < MIN_SAMPLES) {
            this.value = MIN_SAMPLES;
        }
        currentNumSamples = parseInt(this.value);
        updateSamplesButtonsState();

        if (oldValueForReinit !== currentNumSamples && actions > 0 && actions < MAX_ACTIONS && currentScore < N) {
            statusMessageElement.textContent += " (Re-calibrating AI for new sample size...)";
            initializeSamples(); 
            if(ai_xs.length > 0) refineAISamples(); 
        }
    });
    function updateSamplesButtonsState() {
        const val = parseInt(samplesInput.value);
        decrementSamplesBtn.disabled = isNaN(val) || val <= MIN_SAMPLES;
    }
    decrementSamplesBtn.onclick = () => updateSamplesValue(-100);
    incrementSamplesBtn.onclick = () => updateSamplesValue(100);
    function updateSamplesValue(change) { // For +/- buttons
      let currentValue = parseInt(samplesInput.value);
      if(isNaN(currentValue)) currentValue = MIN_SAMPLES;
      let newValue = currentValue + change;
      samplesInput.value = Math.max(MIN_SAMPLES, newValue);
      
      let oldValueForReinit = currentNumSamples;
      currentNumSamples = parseInt(samplesInput.value);
      updateSamplesButtonsState();

      if (oldValueForReinit !== currentNumSamples && actions > 0 && actions < MAX_ACTIONS && currentScore < N) {
            statusMessageElement.textContent += " (Re-calibrating AI for new sample size...)";
            initializeSamples(); 
            if(ai_xs.length > 0) refineAISamples(); 
      }
    }

    document.getElementById('btnScore').onclick = handleScoreCheck;
    document.getElementById('btnAnswer').onclick = revealAnswer;
    document.getElementById('btnDouble').onclick = doubleStake;
    document.getElementById('btnRestart').onclick = restart;
    document.getElementById('btnHowTo').onclick = showModal;

    initGrid();
    coinsDisplay.textContent = coins;
    maxActionsInfoDisplay.textContent = MAX_ACTIONS;
    minIterationsInfoSpan.textContent = MIN_ITERATIONS;
    minSamplesInfoSpan.textContent = MIN_SAMPLES;
    
    iterationsInput.value = currentAiMaxIterations; 
    samplesInput.value = currentNumSamples;

    restart(); 
    updateIterationsButtonsState(); 
    updateSamplesButtonsState();  
  </script>
</body>
</html>