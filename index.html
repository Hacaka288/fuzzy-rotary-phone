<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"/>
  <title>Pattern Predictor Game - Advanced AI v4.1</title>
  <style>
    body {
      display: flex;
      height: 100vh;
      margin: 0;
      background-color: #f0f2f5;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      overflow-x: hidden;
    }

    .sidebar {
      position: fixed;
      left: 0;
      top: 0;
      width: 120px; /* Increased width for new controls */
      height: 100%;
      background-color: #e9ecef;
      padding: 20px 10px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      align-items: center;
      z-index: 10;
      box-shadow: 2px 0 5px rgba(0,0,0,0.1);
    }
    .coin-display {
      font-size: 24px;
      font-weight: bold;
      color: #2a2a2a;
      margin-bottom: 20px; /* Adjusted margin */
      background-color: #ffc107;
      padding: 8px 15px;
      border-radius: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .coin-display span {
      margin-left: 5px;
      font-size: 20px;
    }

    .sidebar-control-group { /* Renamed from stake-controls for generality */
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      margin-bottom: 15px; /* Spacing between control groups */
    }
    .sidebar-control-group label {
      font-size: 13px; /* Slightly smaller for more controls */
      margin-bottom: 6px;
      color: #333;
      font-weight: 500;
    }
    .value-input-wrapper { /* Renamed from stake-input-wrapper */
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .value-input-wrapper button {
      width: 28px;
      height: 28px;
      font-size: 18px;
      font-weight: bold;
      border: 1px solid #ccc;
      background-color: #f8f9fa;
      cursor: pointer;
      color: #333;
      line-height: 1;
    }
    .value-input-wrapper button:hover {
      background-color: #e2e6ea;
    }
    .value-input-wrapper button:first-child {
      border-radius: 5px 0 0 5px;
    }
    .value-input-wrapper button:last-child {
      border-radius: 0 5px 5px 0;
    }
    .value-input-wrapper input {
      height: 28px;
      padding: 5px;
      font-size: 14px; /* Adjusted for consistency */
      border: 1px solid #ccc;
      border-left: none;
      border-right: none;
      border-radius: 0;
      text-align: center;
      box-sizing: border-box;
      -moz-appearance: textfield;
    }
    #stake, #iterations { width: 40px; }
    #samples { width: 55px; } /* Wider for larger numbers */

    .value-input-wrapper input::-webkit-outer-spin-button,
    .value-input-wrapper input::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }

    .main {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      margin-left: 120px; /* Adjusted for wider sidebar */
      padding: 15px;
      box-sizing: border-box;
      position: relative;
    }
    
    .game-content-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 450px;
    }

    #btnToggleConfidence {
      position: absolute;
      top: 15px;
      right: 15px;
      background-color: #28a745;
      color: white;
      border: none;
      padding: 7px 12px;
      font-size: 13px;
      border-radius: 5px;
      cursor: pointer;
      z-index: 5;
      box-shadow: 0 1px 3px rgba(0,0,0,0.15);
    }
    #btnToggleConfidence:hover {
      background-color: #218838;
    }
    #btnAIGuess {
      position: absolute;
      top: 55px;
      right: 15px;
      background-color: #17a2b8;
      color: white;
      border: none;
      padding: 7px 12px;
      font-size: 13px;
      border-radius: 5px;
      cursor: pointer;
      z-index: 5;
      box-shadow: 0 1px 3px rgba(0,0,0,0.15);
    }
    #btnAIGuess:hover {
      background-color: #138496;
    }
    #btnAIGuess:disabled {
      background-color: #adb5bd !important;
      cursor: not-allowed;
    }

    .game-info-area {
      text-align: center;
      margin-bottom: 20px;
      min-height: 65px;
      width: 100%;
    }
    #scoreDisplay, #trialsDisplay {
      font-size: 18px;
      font-weight: 600;
      color: #343a40;
      display: block;
      margin-bottom: 4px;
    }
    #statusMessage {
      font-size: 15px;
      color: #495057;
      margin-top: 8px;
      min-height: 1.3em;
      font-style: italic;
    }

    .button-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
      width: 100%;
      max-width: 340px;
      margin-bottom: 25px;
    }
    .grid-button-container {
      position: relative;
    }
    .grid-button {
      width: 100%;
      aspect-ratio: 1 / 1;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      font-weight: bold;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      background-color: #ff7675;
      color: white;
      transition: background-color 0.2s, transform 0.1s;
      box-sizing: border-box;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .grid-button:active {
      transform: scale(0.95);
    }
    .grid-button.t {
      background-color: #55efc4;
      color: #2d3436;
    }
    .confidence-text {
      position: absolute;
      bottom: 3px;
      right: 5px;
      font-size: 10px;
      color: #2d3436;
      background-color: rgba(255, 255, 255, 0.8);
      padding: 1px 4px;
      border-radius: 3px;
      pointer-events: none;
    }

    .footer {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      width: 100%;
      max-width: 380px;
    }
    .action-button {
      padding: 12px 15px;
      font-size: 15px;
      font-weight: 500;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      width: 100%;
      box-sizing: border-box;
      transition: background-color 0.2s, transform 0.1s;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .action-button:active {
      transform: translateY(1px);
    }
    .action-button:disabled {
      background-color: #adb5bd !important;
      color: #f8f9fa !important;
      cursor: not-allowed;
      box-shadow: none;
    }

    #btnScore { background-color: #28a745; color: white; }
    #btnAnswer { background-color: #ffc107; color: #212529; }
    #btnDouble { background-color: #007bff; color: white; }
    #btnRestart { background-color: #dc3545; color: white; }
    #btnHowTo {
      background-color: #6c757d;
      color: white;
      grid-column: span 2;
    }

    .modal {
      display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background-color: rgba(0, 0, 0, 0.65); z-index: 1000;
    }
    .modal-content {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background-color: #fff; padding: 30px; border-radius: 12px;
      width: 90%; max-width: 500px; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      max-height: 85vh; overflow-y: auto;
    }
    .close-button {
      position: absolute; top: 15px; right: 20px; font-size: 30px;
      cursor: pointer; color: #6c757d; background: none; border: none;
    }
    .modal-content h3 { margin-top: 0; color: #343a40; font-size: 22px; margin-bottom: 15px;}
    .modal-content p { font-size: 16px; line-height: 1.6; color: #495057; }
    .modal-content ul { padding-left: 20px; margin-bottom: 0;}
    .modal-content li { margin: 10px 0; font-size: 15px; color: #495057;} /* Adjusted li margin/font */

    @media (max-width: 768px) {
      .sidebar { width: 100px; padding: 15px 5px;} /* Adjusted width */
      .main { margin-left: 100px; } /* Adjusted margin */
      .coin-display { padding: 6px 10px; font-size: 20px; margin-bottom: 15px; }
      .coin-display span { font-size: 18px; }
      .sidebar-control-group label { font-size: 12px; margin-bottom: 5px; }
      .value-input-wrapper button { width: 24px; height: 24px; font-size: 16px;}
      .value-input-wrapper input { height: 24px; font-size: 13px;}
      #stake, #iterations { width: 36px; }
      #samples { width: 45px; }
    }

    @media (max-width: 500px) {
      .main { padding: 10px; }
      #btnToggleConfidence, #btnAIGuess { font-size: 12px; padding: 6px 10px; top:10px; right:10px;}
      #btnAIGuess { top: 45px; }
      .game-info-area { margin-bottom: 15px; min-height: 60px; }
      #scoreDisplay, #trialsDisplay { font-size: 16px; }
      #statusMessage { font-size: 14px;}
      .button-grid { max-width: 300px; gap: 6px; }
      .grid-button { font-size: 18px; border-radius: 6px; }
      .confidence-text { font-size: 9px; }
      .footer { max-width: 300px; gap: 10px; }
      .action-button { font-size: 14px; padding: 10px 12px; border-radius: 5px;}
    }
  </style>
</head>
<body>
  <div class="sidebar">
    <div class="coin-display">ðŸª™<span id="coins">100</span></div>
    
    <div class="sidebar-control-group">
      <label for="stake">Challenge</label>
      <div class="value-input-wrapper">
        <button id="decrementStake" aria-label="Decrement stake">-</button>
        <input type="number" id="stake" value="10" min="1" step="1">
        <button id="incrementStake" aria-label="Increment stake">+</button>
      </div>
    </div>

    <div class="sidebar-control-group">
      <label for="iterations">AI Iterations</label>
      <div class="value-input-wrapper">
        <button id="decrementIterations" aria-label="Decrement iterations">-</button>
        <input type="number" id="iterations" value="10" min="10" step="1">
        <button id="incrementIterations" aria-label="Increment iterations">+</button>
      </div>
    </div>

    <div class="sidebar-control-group">
      <label for="samples">AI Samples</label>
      <div class="value-input-wrapper">
        <button id="decrementSamples" aria-label="Decrement samples">-</button>
        <input type="number" id="samples" value="3000" min="3000" step="100">
        <button id="incrementSamples" aria-label="Increment samples">+</button>
      </div>
    </div>
  </div>

  <div class="main">
    <button id="btnToggleConfidence">Confidence %</button>
    <button id="btnAIGuess">AI Next Guess</button>
    <div class="game-content-wrapper">
      <div class="game-info-area">
        <span id="scoreDisplay">Score: ? / 16</span>
        <span id="trialsDisplay">Trials: 0 / 9</span>
        <div id="statusMessage">New game started!</div>
      </div>

      <div id="gridDiv" class="button-grid"></div>

      <div class="footer">
        <button id="btnScore" class="action-button">Check Score</button>
        <button id="btnAnswer" class="action-button">Reveal Pattern</button>
        <button id="btnDouble" class="action-button" disabled>X2</button>
        <button id="btnRestart" class="action-button">Restart</button>
        <button id="btnHowTo" class="action-button">How to Play</button>
      </div>
    </div>
    <div id="statusMessageFooter" style="text-align:center; margin-top:10px; font-size:12px; color: #555;"></div>
  </div>

  <div id="modal" class="modal">
    <div class="modal-content">
      <button class="close-button" onclick="hideModal()" aria-label="Close modal">Ã—</button>
      <h3>How to Play</h3>
      <p>Match the hidden pattern of 'T's and 'F's in the 4x4 grid!</p>
      <ul>
        <li>Tap a button to switch its state between 'T' (True) and 'F' (False).</li>
        <li>"Check Score" shows how many of your guesses match the hidden pattern. You have a maximum of <span id="max-actions-info">8</span> tries per game. Your score and trials taken will appear at the top.</li>
        <li>Get a perfect score (16) to win your stake as profit.</li>
        <li>Lose your Challenge Coins if you fail to get a perfect score within the allowed tries.</li>
        <li>Use "X2" after a loss to double your next challenge amount.</li>
        <li><strong>Confidence %:</strong> Tap to see the AI's current belief about each square being 'T'.</li>
        <li><strong>AI Next Guess:</strong> Tap this to have the AI set the grid to its current best guess. Use this, then "Check Score".</li>
        <li>"Reveal Pattern" shows the answer but ends the game (you lose).</li>
        <li><strong>AI Iterations:</strong> Adjust AI refinement cycles (Min: <span id="min-iterations-info">10</span>). More iterations can improve AI accuracy but may slightly increase AI processing time.</li>
        <li><strong>AI Samples:</strong> Set how many example patterns the AI considers (Min: <span id="min-samples-info">3000</span>). More samples and can lead to better AI predictions but will also increase AI processing time.</li>
      </ul>
    </div>
  </div>

  <script>
    const N = 16; // Pattern length
    const MAX_ACTIONS = 8; // Max trials for the player

    let actions = 0;
    let patT = Array(N).fill(0);
    let patG = Array(N).fill(0);
    let currentScore = 0;
    let coins = Math.floor(Math.random() * 101) + 50;

    // DOM Elements
    const gridDiv = document.getElementById('gridDiv');
    const stakeInput = document.getElementById('stake');
    const coinsDisplay = document.getElementById('coins');
    const scoreDisplayElement = document.getElementById('scoreDisplay');
    const trialsDisplayElement = document.getElementById('trialsDisplay');
    const statusMessageElement = document.getElementById('statusMessage');
    const statusMessageFooterElement = document.getElementById('statusMessageFooter');
    const maxActionsInfoDisplay = document.getElementById('max-actions-info');
    const decrementStakeBtn = document.getElementById('decrementStake');
    const incrementStakeBtn = document.getElementById('incrementStake');
    const btnAIGuessDOM = document.getElementById('btnAIGuess');

    const iterationsInput = document.getElementById('iterations');
    const decrementIterationsBtn = document.getElementById('decrementIterations');
    const incrementIterationsBtn = document.getElementById('incrementIterations');
    const samplesInput = document.getElementById('samples');
    const decrementSamplesBtn = document.getElementById('decrementSamples');
    const incrementSamplesBtn = document.getElementById('incrementSamples');
    
    const minIterationsInfoSpan = document.getElementById('min-iterations-info');
    const minSamplesInfoSpan = document.getElementById('min-samples-info');


    const btns = [];
    const confidenceSpans = [];

    // --- Advanced AI State Variables ---
    let ai_xs = []; // Player guesses
    let ai_ys = []; // Corresponding scores
    let ai_samples = []; // Array of sample patterns
    let ai_weights = []; // Weights for each sample
    let ai_currentBelief = new Array(N).fill(0);
    let ai_totalOnesInTruePattern = -1;
    let ai_totalZerosInTruePattern = -1;
    let ai_pastBeliefs = [];
    let ai_initialProbeIndex = 0;
    let ai_isStuckCounter = 0;
    const AI_STUCK_THRESHOLD = 2;
    const NUM_INITIAL_PROBES = 2 + Math.floor(Math.log2(N));
    
    // UI Configurable AI Parameters
    const MIN_ITERATIONS = 10;
    const MIN_SAMPLES = 3000;
    let currentNumSamples = MIN_SAMPLES; 
    let currentAiMaxIterations = MIN_ITERATIONS;
    
    let predictorConfidences = new Array(N).fill(0.5);
    // --- End Advanced AI State Variables ---

    let showConfidence = false;

    function initGrid() {
      statusMessageFooterElement.innerHTML = "By E5";
      for (let i = 0; i < N; i++) {
        const container = document.createElement('div');
        container.className = 'grid-button-container';
        const btn = document.createElement('button');
        btn.className = 'grid-button';
        btn.innerHTML = 'F';
        btn.onclick = () => toggleButton(i);
        const confSpan = document.createElement('span');
        confSpan.className = 'confidence-text';
        confSpan.style.display = 'none';
        btns.push(btn);
        confidenceSpans.push(confSpan);
        container.appendChild(btn);
        container.appendChild(confSpan);
        gridDiv.appendChild(container);
      }
    }

    function toggleButton(i) {
      if (actions < MAX_ACTIONS && !btns[i].disabled) {
        patG[i] = 1 - patG[i];
        updateGridButtonVisual(i);
      }
    }

    function updateGridButtonVisual(i) {
      btns[i].innerHTML = patG[i] ? 'T' : 'F';
      btns[i].className = 'grid-button' + (patG[i] ? ' t' : '');
    }

    function updateAllGridVisualsFromPatG() {
      for (let i = 0; i < N; i++) {
        updateGridButtonVisual(i);
      }
    }

    function generatePattern() {
      let sumT;
      const initialGuessForComparison = new Array(N).fill(0);
      do {
        sumT = 0;
        for (let i = 0; i < N; i++) {
          patT[i] = Math.random() > 0.5 ? 1 : 0;
          if (patT[i] === 1) sumT++;
        }
      } while (sumT === 0 || sumT === N || patT.every((val, idx) => val === initialGuessForComparison[idx]));
    }

    function checkScore(pattern, guess) {
      let score = 0;
      for (let i = 0; i < N; i++) {
        if (pattern[i] === guess[i]) score++;
      }
      return score;
    }

    // --- ADVANCED AI: Monte Carlo Bayesian Predictor ---

    function generateAIInitialProbePatternInternal() {
      let pattern = new Array(N).fill(0);
      if (ai_initialProbeIndex === 0) {
        // All 0s
      } else if (ai_initialProbeIndex === 1) {
        pattern.fill(1);
      } else {
        const freqIndex = ai_initialProbeIndex - 2;
        if (freqIndex < Math.log2(N)) {
          const period = N / Math.pow(2, freqIndex);
          for (let i = 0; i < N; i++) {
            if (Math.floor(i / (period / 2)) % 2 === 0) {
              pattern[i] = 1;
            } else {
              pattern[i] = 0;
            }
          }
        } else {
          for (let i = 0; i < N; i++) pattern[i] = Math.random() > 0.5 ? 1 : 0;
        }
      }
      ai_initialProbeIndex++;
      return pattern;
    }

    function initializeSamples() {
      ai_samples = [];
      ai_weights = [];
      for (let s = 0; s < currentNumSamples; s++) { // Use UI-controlled value
        const sample = new Array(N);
        let onesCount = ai_totalOnesInTruePattern;
        if (onesCount === -1) {
          for (let i = 0; i < N; i++) {
            sample[i] = Math.random() > 0.5 ? 1 : 0;
          }
        } else {
          sample.fill(0);
          const indices = [...Array(N).keys()];
          for (let i = indices.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [indices[i], indices[j]] = [indices[j], indices[i]];
          }
          for (let i = 0; i < onesCount; i++) {
            sample[indices[i]] = 1;
          }
        }
        ai_samples.push(sample);
        ai_weights.push(1 / currentNumSamples); // Use UI-controlled value
      }
    }

    function refineAISamples() {
      if (ai_xs.length === 0) return;

      for (let iter = 0; iter < currentAiMaxIterations; iter++) { // Use UI-controlled value
        let totalWeight = 0;
        for (let s = 0; s < currentNumSamples; s++) { // Use UI-controlled value
          let logLikelihood = 0;
          for (let k = 0; k < ai_xs.length; k++) {
            const guess = ai_xs[k];
            const observedScore = ai_ys[k];
            const predictedScore = checkScore(ai_samples[s], guess);
            const error = Math.abs(observedScore - predictedScore);
            logLikelihood += -error * error; 
          }
          ai_weights[s] = Math.exp(logLikelihood);
          totalWeight += ai_weights[s];
        }

        if (totalWeight > 0) {
          for (let s = 0; s < currentNumSamples; s++) { // Use UI-controlled value
            ai_weights[s] /= totalWeight;
          }
        } else {
          ai_weights.fill(1 / currentNumSamples); // Use UI-controlled value
        }

        const newSamples = [];
        const cumulativeWeights = [];
        let sum = 0;
        for (let s = 0; s < currentNumSamples; s++) { // Use UI-controlled value
          sum += ai_weights[s];
          cumulativeWeights.push(sum);
        }

        for (let s = 0; s < currentNumSamples; s++) { // Use UI-controlled value
          const r = Math.random();
          let idx = 0;
          while (idx < currentNumSamples - 1 && r > cumulativeWeights[idx]) { // Use UI-controlled value
            idx++;
          }
          const baseSample = [...ai_samples[idx]];
          if (Math.random() < 0.1 || iter === 0) { 
            if (ai_totalOnesInTruePattern !== -1) {
              const ones = baseSample.reduce((acc, val) => acc + val, 0);
              if (ones === ai_totalOnesInTruePattern) {
                const i = Math.floor(Math.random() * N);
                const j = Math.floor(Math.random() * N);
                if (baseSample[i] !== baseSample[j]) {
                  [baseSample[i], baseSample[j]] = [baseSample[j], baseSample[i]];
                }
              }
            } else {
              const i = Math.floor(Math.random() * N);
              baseSample[i] = 1 - baseSample[i];
            }
          }
          newSamples.push(baseSample);
        }

        ai_samples = newSamples;
        ai_weights.fill(1 / currentNumSamples); // Use UI-controlled value
      }

      for (let i = 0; i < N; i++) {
        let prob = 0;
        for (let s = 0; s < currentNumSamples; s++) { // Use UI-controlled value
          prob += ai_samples[s][i];
        }
        predictorConfidences[i] = prob / currentNumSamples; // Use UI-controlled value
      }
    }

    function generateAINextBeliefFromSamples() {
      let nextBelief = new Array(N).fill(0);
      if (ai_initialProbeIndex < NUM_INITIAL_PROBES || ai_xs.length === 0) {
        return generateAIInitialProbePatternInternal();
      }

      let bestSampleIdx = 0;
      let bestScore = -Infinity;
      for (let s = 0; s < currentNumSamples; s++) { // Use UI-controlled value
        let sampleScore = 0;
        for (let k = 0; k < ai_xs.length; k++) {
          const predictedScore = checkScore(ai_samples[s], ai_xs[k]);
          const error = Math.abs(ai_ys[k] - predictedScore);
          sampleScore -= error; 
        }
        if (sampleScore > bestScore) {
          bestScore = sampleScore;
          bestSampleIdx = s;
        }
      }
      nextBelief = [...ai_samples[bestSampleIdx]];

      if (ai_totalOnesInTruePattern !== -1) {
        let currentOnes = nextBelief.reduce((sum, bit) => sum + bit, 0);
        let attempts = 0;
        while (currentOnes !== ai_totalOnesInTruePattern && attempts < N * 2) {
          const i = Math.floor(Math.random() * N);
          if (currentOnes > ai_totalOnesInTruePattern && nextBelief[i] === 1) {
            nextBelief[i] = 0;
            currentOnes--;
          } else if (currentOnes < ai_totalOnesInTruePattern && nextBelief[i] === 0) {
            nextBelief[i] = 1;
            currentOnes++;
          }
          attempts++;
        }
      }
      return nextBelief;
    }

    function determineAINextActionAndUpdateBeliefs(playerSubmittedGuess, playerScoreFromPlayerGuess) {
      if (playerSubmittedGuess && playerScoreFromPlayerGuess !== null) {
        const existingGuessIndex = ai_xs.findIndex(existingX => existingX.every((val, idx) => val === playerSubmittedGuess[idx]));
        if (existingGuessIndex === -1) {
          ai_xs.push([...playerSubmittedGuess]);
          ai_ys.push(playerScoreFromPlayerGuess);
        }

        if (playerSubmittedGuess.every(bit => bit === 0)) {
          ai_totalZerosInTruePattern = playerScoreFromPlayerGuess;
          ai_totalOnesInTruePattern = N - playerScoreFromPlayerGuess;
          initializeSamples(); 
        } else if (playerSubmittedGuess.every(bit => bit === 1)) {
          ai_totalOnesInTruePattern = playerScoreFromPlayerGuess;
          ai_totalZerosInTruePattern = N - playerScoreFromPlayerGuess;
          initializeSamples();
        }
      }

      if (ai_samples.length === 0 || ai_samples.length !== currentNumSamples) { // Also re-init if num_samples changed
        initializeSamples();
      }

      refineAISamples();
      let newProposedAIBelief = generateAINextBeliefFromSamples();

      const isEqualToPrevious = ai_pastBeliefs.length > 0 && newProposedAIBelief.every((val, idx) => val === ai_pastBeliefs[ai_pastBeliefs.length - 1][idx]);
      if (isEqualToPrevious && (!playerScoreFromPlayerGuess || playerScoreFromPlayerGuess < N)) {
        ai_isStuckCounter++;
      } else {
        ai_isStuckCounter = 0;
      }

      if (ai_isStuckCounter >= AI_STUCK_THRESHOLD) {
        let mutatedBelief = [...newProposedAIBelief];
        const numToMutate = Math.max(1, Math.floor(N / 4));
        for (let k = 0; k < numToMutate; k++) {
          const i = Math.floor(Math.random() * N);
          const j = Math.floor(Math.random() * N);
          if (mutatedBelief[i] !== mutatedBelief[j]) {
            [mutatedBelief[i], mutatedBelief[j]] = [mutatedBelief[j], mutatedBelief[i]];
          }
        }
        if (ai_totalOnesInTruePattern !== -1) {
          let currentOnes = mutatedBelief.reduce((sum, bit) => sum + bit, 0);
          let attempts = 0;
          while (currentOnes !== ai_totalOnesInTruePattern && attempts < N * 2) {
            const i = Math.floor(Math.random() * N);
            if (currentOnes > ai_totalOnesInTruePattern && mutatedBelief[i] === 1) {
              mutatedBelief[i] = 0;
              currentOnes--;
            } else if (currentOnes < ai_totalOnesInTruePattern && mutatedBelief[i] === 0) {
              mutatedBelief[i] = 1;
              currentOnes++;
            }
            attempts++;
          }
        }
        newProposedAIBelief = mutatedBelief;
        ai_isStuckCounter = 0;
      }

      ai_currentBelief = [...newProposedAIBelief];
      if (ai_pastBeliefs.length > 5) ai_pastBeliefs.shift();
      ai_pastBeliefs.push([...ai_currentBelief]);
      if (showConfidence) displayConfidences();
    }
    // --- END ADVANCED AI ---

    function displayConfidences() {
      confidenceSpans.forEach((span, i) => {
        span.innerHTML = `${(predictorConfidences[i] * 100).toFixed(0)}%`;
        span.style.display = showConfidence ? 'block' : 'none';
      });
    }

    function toggleConfidenceDisplay() {
      showConfidence = !showConfidence;
      displayConfidences();
    }
    document.getElementById('btnToggleConfidence').onclick = toggleConfidenceDisplay;

    function handleAIGuessButtonClick() {
      if (actions >= MAX_ACTIONS || btns[0].disabled) return;
      if (ai_initialProbeIndex === 0 && ai_totalOnesInTruePattern === -1 && ai_xs.length === 0) {
        determineAINextActionAndUpdateBeliefs(null, null);
      }
      patG = [...ai_currentBelief];
      updateAllGridVisualsFromPatG();
      statusMessageElement.textContent = "AI set the grid. Now Check Score.";
      if (showConfidence) displayConfidences();
    }
    btnAIGuessDOM.onclick = handleAIGuessButtonClick;

    function handleScoreCheck() {
      if (actions < MAX_ACTIONS) {
        currentScore = checkScore(patT, patG);
        actions++;

        scoreDisplayElement.textContent = `Score: ${currentScore} / ${N}`;
        trialsDisplayElement.textContent = `Trials: ${actions} / ${MAX_ACTIONS}`;
        statusMessageElement.textContent = `Checked score: ${currentScore}/${N}.`;

        determineAINextActionAndUpdateBeliefs([...patG], currentScore);

        if (currentScore === N) endGame(true);
        else if (actions >= MAX_ACTIONS) endGame(false);

        btnAIGuessDOM.disabled = (actions >= MAX_ACTIONS || currentScore === N);
      }
    }

    function revealAnswer() {
      patG = [...patT];
      updateAllGridVisualsFromPatG();
      currentScore = N;
      endGame(false, true);
    }

    function doubleStake() {
      let currentStake = parseInt(stakeInput.value) || 1;
      let maxPossibleStake = coins > 0 ? coins : 1;
      let newStake = Math.min(currentStake * 2, maxPossibleStake);
      stakeInput.value = newStake;
      updateStakeButtonStates();
      document.getElementById('btnDouble').disabled = true;
      statusMessageElement.textContent = `Next stake doubled to ${newStake}.`;
    }

    function endGame(isWin, revealed = false) {
      scoreDisplayElement.textContent = `Final Score: ${currentScore} / ${N}`;
      trialsDisplayElement.textContent = `Trials: ${actions} / ${MAX_ACTIONS}`;
      let stake = parseInt(stakeInput.value) || 1;
      let message = "";
      if (isWin) {
        coins += stake;
        message = `Perfect! You won ${stake} coins!`;
      } else {
        coins -= stake;
        message = revealed ? `Pattern revealed. Lost ${stake} coins.` : `Game Over! Lost ${stake} coins.`;
      }
      coins = Math.max(0, coins);
      coinsDisplay.textContent = coins;
      statusMessageElement.textContent = message;
      btns.forEach(btn => btn.disabled = true);
      document.getElementById('btnScore').disabled = true;
      document.getElementById('btnAnswer').disabled = true;
      btnAIGuessDOM.disabled = true;

      if (coins > 0) {
        document.getElementById('btnDouble').disabled = isWin;
        stakeInput.disabled = false;
        if (parseInt(stakeInput.value) > coins) stakeInput.value = coins;
        if (parseInt(stakeInput.value) < 1 && coins > 0) stakeInput.value = 1;
      } else {
        document.getElementById('btnDouble').disabled = true;
        stakeInput.value = 0;
        stakeInput.disabled = true;
        statusMessageElement.textContent += " You're out of coins!";
      }
      updateStakeButtonStates();
    }

    function restart() {
      actions = 0;
      currentScore = 0;
      scoreDisplayElement.textContent = `Score: ? / ${N}`;
      trialsDisplayElement.textContent = `Trials: 0 / ${MAX_ACTIONS}`;
      patG.fill(0);
      updateAllGridVisualsFromPatG();
      generatePattern();

      ai_xs = [];
      ai_ys = [];
      ai_samples = [];
      ai_weights = [];
      ai_totalOnesInTruePattern = -1;
      ai_totalZerosInTruePattern = -1;
      ai_pastBeliefs = [];
      ai_initialProbeIndex = 0;
      ai_isStuckCounter = 0;
      predictorConfidences.fill(0.5);
      // Re-initialize AI with current settings, especially if samples/iterations changed
      initializeSamples(); // Use currentNumSamples from UI
      determineAINextActionAndUpdateBeliefs(null, null); 


      btns.forEach(btn => btn.disabled = false);
      document.getElementById('btnScore').disabled = false;
      document.getElementById('btnAnswer').disabled = false;
      document.getElementById('btnDouble').disabled = true;
      btnAIGuessDOM.disabled = false;

      if (coins === 0) {
        stakeInput.value = 0;
        stakeInput.disabled = true;
        document.getElementById('btnScore').disabled = true;
        btnAIGuessDOM.disabled = true;
        statusMessageElement.textContent = "Restarted. You have no coins to play.";
      } else {
        stakeInput.disabled = false;
        let currentStakeVal = parseInt(stakeInput.value);
        if (isNaN(currentStakeVal) || currentStakeVal <= 0 || currentStakeVal > coins) {
          stakeInput.value = Math.max(1, Math.min(coins, 10));
        }
        statusMessageElement.textContent = "New game started!";
      }
      updateStakeButtonStates();
      // Iterations and Samples inputs are not disabled by game state, only by min values
      updateIterationsButtonsState();
      updateSamplesButtonsState();
    }

    function showModal() { document.getElementById('modal').style.display = 'block'; }
    function hideModal() { document.getElementById('modal').style.display = 'none'; }

    // --- Stake Controls ---
    function updateStakeValue(change) {
      let currentValue = parseInt(stakeInput.value) || 0;
      let newValue = currentValue + change;
      if (coins === 0) {
        stakeInput.value = 0;
      } else {
        stakeInput.value = Math.max(1, Math.min(newValue, coins));
      }
      updateStakeButtonStates();
    }
    function updateStakeButtonStates() {
      const val = parseInt(stakeInput.value);
      const stakeDisabled = stakeInput.disabled;
      decrementStakeBtn.disabled = stakeDisabled || val <= 1;
      incrementStakeBtn.disabled = stakeDisabled || val >= coins;
    }
    stakeInput.addEventListener('input', function() {
      let value = parseInt(this.value);
      if (isNaN(value)) {
        this.value = (coins > 0) ? 1 : 0;
      } else if (coins === 0) {
        this.value = 0;
      } else {
        this.value = Math.max(1, Math.min(value, coins));
      }
      updateStakeButtonStates();
    });
    decrementStakeBtn.onclick = () => updateStakeValue(-1);
    incrementStakeBtn.onclick = () => updateStakeValue(1);

    // --- Iterations Controls ---
    function updateIterationsValue(change) {
      let currentValue = parseInt(iterationsInput.value) || MIN_ITERATIONS;
      let newValue = currentValue + change;
      iterationsInput.value = Math.max(MIN_ITERATIONS, newValue);
      currentAiMaxIterations = parseInt(iterationsInput.value);
      updateIterationsButtonsState();
    }
    function updateIterationsButtonsState() {
      const val = parseInt(iterationsInput.value);
      decrementIterationsBtn.disabled = val <= MIN_ITERATIONS;
    }
    iterationsInput.addEventListener('input', function() {
      let value = parseInt(this.value);
      if (isNaN(value) || value < MIN_ITERATIONS) {
        this.value = MIN_ITERATIONS;
      }
      currentAiMaxIterations = parseInt(this.value);
      updateIterationsButtonsState();
    });
    decrementIterationsBtn.onclick = () => updateIterationsValue(-1);
    incrementIterationsBtn.onclick = () => updateIterationsValue(1);

    // --- Samples Controls ---
    function updateSamplesValue(change) {
      let currentValue = parseInt(samplesInput.value) || MIN_SAMPLES;
      let newValue = currentValue + change;
      samplesInput.value = Math.max(MIN_SAMPLES, newValue);
      currentNumSamples = parseInt(samplesInput.value);
      updateSamplesButtonsState();
      // If game is active, might want to re-init AI samples
      if (actions > 0 && actions < MAX_ACTIONS && currentScore < N && (ai_samples.length === 0 || ai_samples.length !== currentNumSamples)) {
          initializeSamples(); // Re-initialize with new sample count
          if(ai_xs.length > 0) refineAISamples(); // Refine if we have data
      }
    }
    function updateSamplesButtonsState() {
      const val = parseInt(samplesInput.value);
      decrementSamplesBtn.disabled = val <= MIN_SAMPLES;
    }
    samplesInput.addEventListener('input', function() {
      let value = parseInt(this.value);
      if (isNaN(value) || value < MIN_SAMPLES) {
        this.value = MIN_SAMPLES;
      }
      let oldNumSamples = currentNumSamples;
      currentNumSamples = parseInt(this.value);
      updateSamplesButtonsState();
      if (oldNumSamples !== currentNumSamples && actions > 0 && actions < MAX_ACTIONS && currentScore < N && (ai_samples.length === 0 || ai_samples.length !== currentNumSamples)) {
          initializeSamples();
          if(ai_xs.length > 0) refineAISamples();
      }
    });
    decrementSamplesBtn.onclick = () => updateSamplesValue(-100);
    incrementSamplesBtn.onclick = () => updateSamplesValue(100);


    // Game Buttons
    document.getElementById('btnScore').onclick = handleScoreCheck;
    document.getElementById('btnAnswer').onclick = revealAnswer;
    document.getElementById('btnDouble').onclick = doubleStake;
    document.getElementById('btnRestart').onclick = restart;
    document.getElementById('btnHowTo').onclick = showModal;

    // Initial Setup
    initGrid();
    coinsDisplay.textContent = coins;
    maxActionsInfoDisplay.textContent = MAX_ACTIONS;
    minIterationsInfoSpan.textContent = MIN_ITERATIONS;
    minSamplesInfoSpan.textContent = MIN_SAMPLES;
    
    iterationsInput.value = currentAiMaxIterations; // Set initial UI values
    samplesInput.value = currentNumSamples;

    restart(); // This also calls updateStakeButtonStates, etc.
    updateIterationsButtonsState(); // Ensure initial state is correct
    updateSamplesButtonsState();   // Ensure initial state is correct
  </script>
</body>
</html>